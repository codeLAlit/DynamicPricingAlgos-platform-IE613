# -*- coding: utf-8 -*-
"""Dynamic Pricing Thompson Sampling (All Independent).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yJx9xjrLQUd7xaU_Zo2REW7eVmvpWlta
"""

import matplotlib.pyplot as plt
import random
import math as mt
import numpy as np
import tqdm.notebook as tqdm
import time
import scipy.stats as stats

def get_theta(pi, fit, pit_1):
    return (pi**2)*(fit/pit_1)-fit*pi

def get_rbar_t(pi, fit):
    return fit*pi

def get_rt(pi, demand):
    return demand*pi

def get_mt(theta, lam, noise_var):
    return (theta**2)/noise_var+lam

def get_mt_bt(rev, rev_bar, theta, noise_var):
    return  (rev-rev_bar)*theta/noise_var

def get_sigma(sig_t1, mt):
    sig_t1_inv = 1/sig_t1
    res = sig_t1_inv + mt
    return 1/res

def get_mu(sig_t1, mt, mu_t1, rev, rev_bar, theta, noise_var):
    sig_t = get_sigma(sig_t1, mt)
    sig_t1_inv = 1/sig_t1
    mu_t = sig_t*(sig_t1_inv*mu_t1 + get_mt_bt(rev, rev_bar, theta, noise_var))
    return mu_t

def get_forecast(beta, prev_bd):
    c0 = 1e-4
    et = np.random.normal(0, 1, 1)
    ft = c0 + beta*prev_bd + et
    return ft

def get_demand(price, prev_price, initial_elasticity, fit):
    et = np.random.normal(0, 1, 1)
    a = fit*((price/prev_price)**initial_elasticity)
    dt = max(a, 0)
    return dt

def get_price(fit, prev_price, constraint_set, elasticity):
    revs = (constraint_set**2)*fit*elasticity/prev_price - constraint_set*fit*(elasticity-1)
    idx = np.argmax(revs)
    return constraint_set[idx]

def max_rev_ts(initial_price, initial_elasticity, initial_demand, time_h, noise_var, constraint_set):

    revenue = np.zeros(time_h)

    lam = 1e-4
    price =  initial_price
    demand = initial_demand
    elast_t = -2
    theta = 0
    forecast = 1e-4 + np.random.normal(0, 1, 1) + initial_demand
    
    prev_bd = demand
    prev_price = price
    sig_t1 = 0
    mt = get_mt(theta, lam, noise_var)
    mu_t1 = 0

    rev = get_rt(price, demand)
    rev_bar = get_rbar_t(price, forecast)

    mu = -2
    sig = 6

    for t in range(1, time_h+1):

        while True:
            samp = np.random.normal(mu, sig, 1)
            elast_t = samp
            if elast_t <0 :
                break

        forecast = get_forecast(0.5, prev_bd)
        price = get_price(forecast, prev_price, constraint_set, elast_t)
        demand = get_demand(price, prev_price, initial_elasticity, forecast)

        rev = get_rt(price, demand)
        rev_bar = get_rbar_t(price, forecast)

        revenue[t-1] = rev

        sig_t1 = sig
        mu_t1 = mu
        theta = get_theta(price, forecast, prev_price)
        mt = get_mt(theta, lam, noise_var)

        mu = get_mu(sig_t1, mt, mu_t1, rev, rev_bar, theta, noise_var)
        sig = get_sigma(sig_t1, mt)
        prev_bd = 0.5*prev_bd + demand
        prev_price = price
    print("Run completed Successfully")
    return revenue


def run_ts(price_a, dem_a, elast_a, time_h, noise_var, cs_a, num_items):
    revenue = np.zeros(time_h)
    labels = np.arange(1, time_h+1, 1)

    for i in range(num_items):
        rev = max_rev_ts(price_a[i], elast_a[i], dem_a[i], time_h, noise_var, cs_a[i, :])
        revenue = revenue + rev
    return labels, revenue